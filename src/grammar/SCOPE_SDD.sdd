new_table_entry(identifier_label: str, datatype: str, dimesions: List[int], line: int) -> TableEntry
concat(l1: List[Any], l2: List[Any])
new_scope(table: List[TableEntry], upper_scope: Scope) -> Scope
Scope.add(entry: TableEntry)
Scope.add_many(entries: List[TableEntry])

production:
    VARDECL : DATATYPE "ident" OPT_VECTOR
rules:
    VARDECL.entry = new_table_entry(ident.text, DATATYPE.type, OPT_VECTOR.sin, ident.lineno)

production:
    DATATYPE : "int"
rules:
    DATATYPE.type = "int"

production:
    DATATYPE : "float"
rules:
    DATATYPE.type = "float"

production:
    DATATYPE : "string"
rules:
    DATATYPE.type = "string"

production:     
    OPT_VECTOR : "[" "int_constant" "]" OPT_VECTOR1
rules:
    OPT_VECTOR.sin = concat([int_constant.value], OPT_VECTOR1.sin)

production:
    OPT_VECTOR : &
rules:
    OPT_VECTOR.sin = []

production:
    FUNCDEF : "def" "ident" "(" PARAMLIST ")" "{" STATELIST "}"
rules:
    FUNCDEF.scope = STATELIST.upper_scope
    FUNCDEF.scope.add_many(PARAMLIST.entries)
    FUNCDEF.name = ident.value

production:
    PARAMLIST : DATATYPE "ident" PARAMLISTAUX
rules:
    PARAMLIST.entries = concat([new_table_entry(ident.text, DATATYPE.type, [], ident.lineno)], PARAMLISTAUX.entries)

production:
    PARAMLIST : &
rules:
    PARAMLIST.entries = []

production:
    PARAMLISTAUX : "," PARAMLIST
rules:
    PARAMLISTAUX.entries = PARAMLIST.entries

production:
    PARAMLISTAUX : &
rules:
    PARAMLISTAUX.entries = []

production:
    FORSTAT : "for" "(" ATRIBSTAT ";" EXPRESSION ";" ATRIBSTAT ")" STATEMENT
rules:
    STATEMENT.upper_scope = FORSTAT.scope

production:
    STATEMENT : VARDECL ";"
rules:
    STATEMENT.entry = VARDECL.entry

production:
    STATEMENT : IFSTAT
rules:
    IFSTAT.scope = new_scope([], STATEMENT.upper_scope)

production:
    STATEMENT : FORSTAT
rules:
    FORSTAT.scope = new_scope([], STATEMENT.upper_scope)

production:
    STATEMENT : "{" STATELIST "}"
rules:
    STATELIST.upper_scope = STATEMENT.upper_scope

production:
    IFSTAT : "if" "(" EXPRESSION ")" "{" STATELIST "}" OPT_ELSE
rules:
    STATELIST.upper_scope = IFSTAT.upper_scope
    OPT_ELSE.scope = new_scope([], IFSTAT.scope)

production:
    OPT_ELSE : "else" "{" STATELIST "}"
rules:
    STATELIST.upper_scope = OPT_ELSE.scope

production:
    OPT_ELSE : &
rules:
    -

production:
    STATELIST : STATEMENT OPT_STATELIST
rules:
    STATEMENT.upper_scope = STATELIST.upper_scope
    OPT_STATELIST.upper_scope = STATELIST.upper_scope

production:
    OPT_STATELIST : STATELIST
rules:
    STATELIST.upper_scope = OPT_STATELIST.upper_scope

production:
    OPT_STATELIST : &
rules:
    -

production:
    PROGRAM : STATEMENT
rules:
    PROGRAM.scope = new_scope([], null)
    STATEMENT.upper_scope = PROGRAM.scope


production:
    PROGRAM : FUNCLIST
rules:
    PROGRAM.scope = new_scope([], null)
    FUNCLIST.upper_scope = PROGRAM.scope

production:
    PROGRAM : &
rules:
    -

production:
    FUNCLIST : FUNCDEF FUNCLISTAUX
rules:
    FUNCLISTAUX.upper_scope = FUNCLIST.upper_scope
    FUNCLIST.upper_scope.add(new_table_entry(FUNCDEF.label, "function", [], FUNCDEF.lineno))

production:
    FUNCLISTAUX : FUNCLIST
rules:
    FUNCLIST.upper_scope = FUNCLISTAUX.upper_scope

production:
    FUNCLISTAUX : &  
rules:
    -